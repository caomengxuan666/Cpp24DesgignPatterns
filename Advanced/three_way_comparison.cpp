// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
// â”ƒ  MODULE   ::  Three-way Comparison Operator (<=>)                           â”ƒ
// â”ƒ  PURPOSE   ::  Auto-generate comparison operators in C++20                  â”ƒ
// â”ƒ  CATEGORY  ::  Modern C++20 Idiom                                           â”ƒ
// â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

/**
 * @file    three_way_comparison.cpp
 * @brief   C++20 ä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦ï¼ˆ<=>ï¼‰å®æˆ˜
 * @details 
 *          C++20 å¼•å…¥äº† <=> è¿ç®—ç¬¦ï¼ˆå¤ªç©ºèˆ¹è¿ç®—ç¬¦ï¼‰ï¼Œå¯ä»¥è‡ªåŠ¨ç”Ÿæˆ ==, !=, <, <=, >, >=ã€‚
 *          å®ƒç®€åŒ–äº†ç±»å‹æ¯”è¾ƒé€»è¾‘ï¼Œæ˜¯ç°ä»£ C++ çš„æ ¸å¿ƒç‰¹æ€§ä¹‹ä¸€ã€‚
 * 
 * @par æ ¸å¿ƒæ€æƒ³
 *      - ä½¿ç”¨ auto operator<=>(const T&) const = default
 *      - ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆæ‰€æœ‰æ¯”è¾ƒæ“ä½œ
 *      - æ”¯æŒå¼ºç±»å‹å®‰å…¨æ¯”è¾ƒ
 * 
 * @note    éœ€è¦ C++20 ç¼–è¯‘å™¨æ”¯æŒï¼ˆMSVC 19.20+, GCC 10+, Clang 10+ï¼‰
 * @warning ä¸é€‚ç”¨äºéœ€è¦è‡ªå®šä¹‰æ¯”è¾ƒé€»è¾‘çš„å¤æ‚ç±»å‹
 * @todo    ç»“åˆ Concepts çº¦æŸå¯æ¯”è¾ƒç±»å‹
 * @date    2025-08-19
 * @version 1.0
 */

#include <compare>// ä¸‰è·¯æ¯”è¾ƒæ‰€éœ€å¤´æ–‡ä»¶
#include <format>
#include <iostream>
#include <print>
#include <string>

using std::println;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1ï¸âƒ£ åŸºæœ¬ä½¿ç”¨ï¼šé»˜è®¤ç”Ÿæˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

struct Point {
    int x, y;

    // âœ… è‡ªåŠ¨ç”Ÿæˆæ‰€æœ‰æ¯”è¾ƒæ“ä½œ
    auto operator<=>(const Point &) const = default;
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2ï¸âƒ£ è‡ªå®šä¹‰æ¯”è¾ƒé€»è¾‘ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

struct Version {
    int major, minor, patch;

    // è‡ªå®šä¹‰æ¯”è¾ƒé€»è¾‘
    auto operator<=>(const Version &other) const {
        if (auto cmp = major <=> other.major; cmp != 0) return cmp;
        if (auto cmp = minor <=> other.minor; cmp != 0) return cmp;
        return patch <=> other.patch;
    }

    // ä»éœ€æ‰‹åŠ¨å®ç° ==ï¼ˆC++20 ä¸­ <=> ä¸è‡ªåŠ¨æ¨å¯¼ ==ï¼Œä½†å¯ä»¥ä¼˜åŒ–ï¼‰
    bool operator==(const Version &other) const = default;
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3ï¸âƒ£ éƒ¨åˆ†è‡ªåŠ¨ç”Ÿæˆï¼ˆæ··åˆæ¨¡å¼ï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

struct Name {
    std::string first, last;

    // è‡ªåŠ¨ç”Ÿæˆ == å’Œ !=
    bool operator==(const Name &) const = default;

    // è‡ªåŠ¨ç”Ÿæˆ <, <=, >, >=
    auto operator<=>(const Name &) const = default;
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 4ï¸âƒ£ å¼ºç±»å‹æ¯”è¾ƒï¼ˆè¿”å›ç±»å‹ï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

enum class Priority {
    Low,
    Medium,
    High
};

struct Task {
    std::string name;
    Priority priority;

    // è¿”å›å¼ºç±»å‹ std::strong_ordering
    auto operator<=>(const Task &other) const {
        // ä¼˜å…ˆæŒ‰ priority æ¯”è¾ƒ
        if (auto cmp = priority <=> other.priority; cmp != 0) return cmp;
        // å†æŒ‰ name æ¯”è¾ƒ
        return name <=> other.name;
    }
    
    // é»˜è®¤å®ç°
    bool operator==(const Task &other) const = default;
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ æµ‹è¯•å‡½æ•° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

void testBasicComparison() {
    println("\nğŸ§ª 1. åŸºæœ¬æ¯”è¾ƒï¼ˆPointï¼‰");

    Point p1{1, 2}, p2{1, 3}, p3{1, 2};

    println("p1 < p2: {}", p1 < p2);
    println("p1 == p3: {}", p1 == p3);
    println("p1 != p2: {}", p1 != p2);
}

void testCustomLogic() {
    println("\nğŸ§ª 2. è‡ªå®šä¹‰æ¯”è¾ƒï¼ˆVersionï¼‰");

    Version v1{1, 2, 3}, v2{1, 3, 0}, v3{1, 2, 3};

    println("v1 < v2: {}", v1 < v2);
    println("v1 == v3: {}", v1 == v3);
    println("v2 > v1: {}", v2 > v1);
}

void testMixedMode() {
    println("\nğŸ§ª 3. æ··åˆæ¨¡å¼ï¼ˆNameï¼‰");

    Name n1{"Alice", "Smith"}, n2{"Bob", "Smith"}, n3{"Alice", "Smith"};

    println("n1 == n3: {}", n1 == n3);
    println("n1 < n2: {}", n1 < n2);
}

void testStrongOrdering() {
    println("\nğŸ§ª 4. å¼ºç±»å‹æ¯”è¾ƒï¼ˆTaskï¼‰");

    Task t1{"Task A", Priority::High};
    Task t2{"Task B", Priority::Medium};
    Task t3{"Task C", Priority::High};

    println("t1 > t2: {}", t1 > t2);
    println("t1 == t3: {}", t1 == t3);
    println("t1 < t3: {}", t1 < t3);// åŒä¼˜å…ˆçº§ï¼ŒæŒ‰åå­—æ¯”è¾ƒ
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ä¸»å‡½æ•° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

int main() {
    println("ğŸ¯ å¼€å§‹æµ‹è¯• C++20 ä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦");

    testBasicComparison();
    testCustomLogic();
    testMixedMode();
    testStrongOrdering();

    println("\nâœ… æ‰€æœ‰æµ‹è¯•å®Œæˆï¼");
    return 0;
}